## 元组、列表

列表和元组都是有序的，可以存储任意数据类型的集合，区别主要在于下面这两点:

- **列表是动态的，长度可变，可以随意的增加、删减或改变元素。列表的存储空间略大于元组，性能略逊于元组**。
  - 由于列表可变，所以需要额外存储已经分配的长度大小（8 字节），这样才可以实时追踪列表空间的使用情况，当空间不足时，及时分配额外空间

    ```python
        
    l = []
    l.__sizeof__() // 空列表的存储空间为40字节
    40
    l.append(1)
    l.__sizeof__() 
    72 // 加入了元素1之后，列表为其分配了可以存储4个元素的空间 (72 - 40)/8 = 4
    l.append(2) 
    l.__sizeof__()
    72 // 由于之前分配了空间，所以加入元素2，列表空间不变
    l.append(3)
    l.__sizeof__() 
    72 // 同上
    l.append(4)
    l.__sizeof__() 
    72 // 同上
    l.append(5)
    l.__sizeof__() 
    104 // 加入元素5之后，列表的空间不足，所以又额外分配了可以存储4个元素的空间
    ```

    为了减小每次增加 / 删减操作时空间分配的开销，Python 每次分配空间时都会额外多分配一些，这样的机制（over-allocating）保证了其操作的高效性：增加 / 删除的时间复杂度均为 O(1)。

- **元组是静态的，长度大小固定，不可以对元素进行增加、删减或者改变操作。元组相对于列表更加轻量级，性能稍优。**
  - Python 会在后台，对静态数据做一些资源缓存（resource caching）。通常来说，因为垃圾回收机制的存在，如果一些变量不被使用了，Python 就会回收它们所占用的内存，返还给操作系统，以便其他变量或其他应用使用。

  - 对于一些静态变量，比如元组，如果它不被使用并且占用空间不大时，Python 会暂时缓存这部分内存。这样，下次我们再创建同样大小的元组时，Python 就可以不用再向操作系统发出请求，去寻找内存，而是可以直接分配之前缓存的内存空间，这样就能大大加快程序的运行速度。

![20220507111028](https://cdn.jsdelivr.net/gh/xihuishawpy/PicBad@main/blogs/pictures/20220507111028.png)

## 字典、集合

使用 `get(key, default)`函数来进行索引。如果键不存在，调用 get() 函数可以返回一个默认值

```python
d = {'name': 'jason', 'age': 20}
d.get('name')
'jason'
d.get('location', 'null')
'null'
```

集合并不支持索引操作，因为**集合本质上是一个哈希表**，和列表不一样.

想要判断一个元素在不在字典或集合内，我们可以用 value in dict/set 来判断。

```python

s = {1, 2, 3}
1 in s
True
10 in s
False

d = {'name': 'jason', 'age': 20}
'name' in d
True
'location' in d
False
```

**不同于其他数据结构，字典和集合的内部结构都是一张哈希表。**

- 对于字典而言，这张表存储了哈希值（hash）、键和值这 3 个元素。

- 而对集合来说，区别就是哈希表内没有键和值的配对，只有单一的元素了。

## 条件、循环

### for 和 while

如果你只是<u>遍历一个已知的集合</u>，找出满足条件的元素，并进行相应的操作，那么使用 **for 循环**更加简洁。

但如果你需要在满足某个条件前，不停地重复某些操作，并且<u>没有特定的集合需要去遍历</u>，那么一般则会使用 **while 循环**

### continue 和 break 

现在要找出价格小于 1000，并且颜色不是红色的所有产品名称和颜色的组合

常规写法：

```python

# name_price: 产品名称(str)到价格(int)的映射字典
# name_color: 产品名字(str)到颜色(list of str)的映射字典
for name, price in name_price.items():
    if price < 1000:
        if name in name_color:
            for color in name_color[name]:
                if color != 'red':
                    print('name: {}, color: {}'.format(name, color))
        else:
            print('name: {}, color: {}'.format(name, 'None'))

```

加入 continue 后，代码显然清晰了很多：

```python

# name_price: 产品名称(str)到价格(int)的映射字典
# name_color: 产品名字(str)到颜色(list of str)的映射字典
for name, price in name_price.items():
    if price >= 1000:
        continue
    if name not in name_color:
        print('name: {}, color: {}'.format(name, 'None'))
        continue
    for color in name_color[name]:
        if color == 'red':
            continue
        print('name: {}, color: {}'.format(name, color))
```

所谓 **continue，就是让程序跳过当前这层循环，继续执行下面的循环**；而 **break 则是指完全跳出所在的整个循环体**



### 条件与循环的复用

举个例子，比如我们要绘制 y = 2*|x| + 5 的函数图像，给定集合 x 的数据点，需要计算出 y 的数据集合，那么只用一行代码，就可以很轻松地解决问题了：

```python

y = [value * 2 + 5 if value > 0 else -value * 2 + 5 for value in x]
```

再比如，将文件中逐行读取的一个完整语句，按逗号分割单词，去掉首位的空字符，并过滤掉长度小于等于 3 的单词，最后返回由单词组成的列表。这同样可以简洁地表达成一行：

```python

text = ' Today,  is, Sunday'
text_list = [s.strip() for s in text.split(',') if len(s.strip()) > 3]
print(text_list)
['Today', 'Sunday']
```

思考：给定下面两个列表 attributes 和 values，要求针对 values 中每一组子列表 value，输出其和 attributes 中的键对应后的字典，最后返回字典组成的列表。

```python

attributes = ['name', 'dob', 'gender']
values = [['jason', '2000-01-01', 'male'], 
['mike', '1999-01-01', 'male'],
['nancy', '2001-02-01', 'female']
]

# expected output:
[{'name': 'jason', 'dob': '2000-01-01', 'gender': 'male'}, 
{'name': 'mike', 'dob': '1999-01-01', 'gender': 'male'}, 
{'name': 'nancy', 'dob': '2001-02-01', 'gender': 'female'}]
```

解答：

```python
[dict(zip(attributes,v)) for v in values]
```
