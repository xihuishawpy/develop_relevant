## 元组、列表

列表和元组都是有序的，可以存储任意数据类型的集合，区别主要在于下面这两点:

- **列表是动态的，长度可变，可以随意的增加、删减或改变元素。列表的存储空间略大于元组，性能略逊于元组**。
  - 由于列表可变，所以需要额外存储已经分配的长度大小（8 字节），这样才可以实时追踪列表空间的使用情况，当空间不足时，及时分配额外空间

    ```python
        
    l = []
    l.__sizeof__() // 空列表的存储空间为40字节
    40
    l.append(1)
    l.__sizeof__() 
    72 // 加入了元素1之后，列表为其分配了可以存储4个元素的空间 (72 - 40)/8 = 4
    l.append(2) 
    l.__sizeof__()
    72 // 由于之前分配了空间，所以加入元素2，列表空间不变
    l.append(3)
    l.__sizeof__() 
    72 // 同上
    l.append(4)
    l.__sizeof__() 
    72 // 同上
    l.append(5)
    l.__sizeof__() 
    104 // 加入元素5之后，列表的空间不足，所以又额外分配了可以存储4个元素的空间
    ```

    为了减小每次增加 / 删减操作时空间分配的开销，Python 每次分配空间时都会额外多分配一些，这样的机制（over-allocating）保证了其操作的高效性：增加 / 删除的时间复杂度均为 O(1)。

- **元组是静态的，长度大小固定，不可以对元素进行增加、删减或者改变操作。元组相对于列表更加轻量级，性能稍优。**
  - Python 会在后台，对静态数据做一些资源缓存（resource caching）。通常来说，因为垃圾回收机制的存在，如果一些变量不被使用了，Python 就会回收它们所占用的内存，返还给操作系统，以便其他变量或其他应用使用。

  - 对于一些静态变量，比如元组，如果它不被使用并且占用空间不大时，Python 会暂时缓存这部分内存。这样，下次我们再创建同样大小的元组时，Python 就可以不用再向操作系统发出请求，去寻找内存，而是可以直接分配之前缓存的内存空间，这样就能大大加快程序的运行速度。

![20220507111028](https://cdn.jsdelivr.net/gh/xihuishawpy/PicBad@main/blogs/pictures/20220507111028.png)



## 字典、集合 

使用 `get(key, default) `函数来进行索引。如果键不存在，调用 get() 函数可以返回一个默认值

```python
d = {'name': 'jason', 'age': 20}
d.get('name')
'jason'
d.get('location', 'null')
'null'
```

集合并不支持索引操作，因为**集合本质上是一个哈希表**，和列表不一样.

想要判断一个元素在不在字典或集合内，我们可以用 value in dict/set 来判断。

```python

s = {1, 2, 3}
1 in s
True
10 in s
False

d = {'name': 'jason', 'age': 20}
'name' in d
True
'location' in d
False
```

**不同于其他数据结构，字典和集合的内部结构都是一张哈希表。**

- 对于字典而言，这张表存储了哈希值（hash）、键和值这 3 个元素。

- 而对集合来说，区别就是哈希表内没有键和值的配对，只有单一的元素了。